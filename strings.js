/**
 * 67. Add Binary
 * Given two binary strings a and b, return their sum as a binary string.
 */

/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
 var addBinary = function(a, b) {
    const arrA = a.split("").reverse();
    const arrB = b.split("").reverse();
    let carry = 0;
    let answer = [];
    let i = 0;
    const len = a.length > b.length ? a.length : b.length;

  while (i < len) {
    const x = arrA[i] ? +arrA[i] : 0;
    const y = arrB[i] ? +arrB[i] : 0;
    const sum = carry + x + y;
    carry = Math.floor(sum / 2);
    answer.unshift(sum % 2);
    i++;
  }

  if (carry > 0) answer.unshift(carry);

  return answer.join("");
};






/**
 * 389. Find the Difference
 * You are given two strings s and t.
 * String t is generated by random shuffling string s and then add one more letter at a random position.
 * Return the letter that was added to t.
 */

/**
 * @param {string} s
 * @param {string} t
 * @return {character}
 */
 var findTheDifference = function(s, t) {
    s = s.split("").sort();
    t = t.split("").sort();
    
    for(let i = 0; i < s.length; i++){
        if( s[i] !== t[i]) {
            return t[i]
        }
    }
    return t[t.length -1]
    
};




/**
 * 1047. Remove All Adjacent Duplicates In String
 * You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.
 * We repeatedly make duplicate removals on s until we no longer can.
 * Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.
 */


/**
 * @param {string} s
 * @return {string}
 */
 var removeDuplicates = function(s) {
    let res = [];
    
    for(let i = 0; i < s.length; i++){
        s[i] !== res[res.length-1] ? res.push(s[i]) : res.pop();
        
    }
    return res.join("")
  
};





/**
 * 344. Reverse String
 * Write a function that reverses a string. The input string is given as an array of characters s.
 * You must do this by modifying the input array in-place with O(1) extra memory.
 */

/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
 var reverseString = function(s) {
  for (let i = 0; i < s.length/2; i++) {
      let temp = s[i]
      s[i] = s[s.length-i-1]
      s[s.length-i-1] = temp
  }
};


/**
 * 409. Longest Palindrome
 * Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.
 * Letters are case sensitive, for example, "Aa" is not considered a palindrome here.
 */

/**
 * @param {string} s
 * @return {number}
 */
 var longestPalindrome = function(s) {
  let m = new Map();
  for (let i = 0; i < s.length; i++) {
      m.set(s[i], m.get(s[i]) + 1 || 1);
  }
  let numOfOdds = 0;
  for (let value of m.values()) {
      if (value % 2 === 1) {
          numOfOdds += 1;
      }
  }
  return numOfOdds > 0 ? s.length - numOfOdds + 1 : s.length;
};


/**
 * Uncompress
 * Write a function, uncompress, that takes in a string as an argument. The input string will be formatted into multiple groups according to the following pattern:
 * <number><char>
 * The function should return an uncompressed version of the string where each 'char' of a group is repeated 'number' times consecutively. 
 * You may assume that the input string is well-formed according to the previously mentioned pattern.
 * 
 * NOTE: strings are immutable in JS, concatinating results in a new string 0(n), need to use an array 
 * 
 * Time complexity: O(nm) where n is the number of number character pairs or groups and m is the largest number of any group
 */

const uncompress = (s) => {
    let res = [];
    const numbers = '0123456789';
    let i = 0;
    let j = 0;
    while(j < s.length){
      if(numbers.includes(s[j])){
        j += 1;
      } else {
        const num = s.slice(i, j)
        for(let count = 0; count < num; count++){
          res.push(s[j]);
        }
        j += 1;
        i = j;
      }
      
    }
      
    return res.join('');
};

console.log(uncompress("2c3a1t"))
console.log(uncompress("4s2b"))
console.log(uncompress("2p1o5p"))
console.log(uncompress("3n12e2z"))
console.log(uncompress("127y"))


/**
 * Compress
 * Write a function, compress, that takes in a string as an argument. 
 * The function should return a compressed version of the string where consecutive occurrences of the same characters are compressed into the number of occurrences followed by the character.
 * Single character occurrences should not be changed.
 * 'aaa' compresses to '3a'
 * You can assume that the input only contains alphabetic characters.
 * 
 * Time Complexity O(n)
 */

const compress = (s) => {
  let res = [];
  let i = 0;
  let j = 0;
  let count = 0;
  
  while(j <= s.length) {
    if(s[j] === s[i]) {
      j += 1
    } else {
      let num = j - i;
      if(num === 1){
        res.push(s[i]);
      } else {
        res.push(num, s[i]);
      }
      i = j;
    }
      
  }
  return res.join('');
};


console.log(compress('ccaaatsss'))
console.log(compress('ssssbbz'))
console.log(compress('ppoppppp'))
console.log(compress('nnneeeeeeeeeeeezz'))
console.log(compress('yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'))




/**
 * 412. Fizz Buzz
 */


var fizzBuzz = function(n) {
  let ans = []
  for (let i = 1; i <= n; i++){
      if ( i % 3 === 0 && i % 5 === 0){
          ans[i] = "FizzBuzz"
      } else if (i % 3 === 0){
          ans[i] = "Fizz"
      } else if (i % 5 === 0 ){
          ans[i] = "Buzz"
      } else {
          ans[i] = `${i}`
      }
  }
  ans.shift()
  return ans;
};

console.log(fizzBuzz(3))
console.log(fizzBuzz(5))
console.log(fizzBuzz(21))
console.log(fizzBuzz(4))